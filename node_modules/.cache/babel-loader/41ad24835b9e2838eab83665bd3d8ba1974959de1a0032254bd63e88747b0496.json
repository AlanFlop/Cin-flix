{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// src/store/modules/auth.js\nimport authService from '@/services/auth.service';\nimport router from '@/router';\nexport default {\n  namespaced: true,\n  state: {\n    user: authService.getUser(),\n    isLoggingIn: false,\n    isRegistering: false,\n    error: null,\n    isAuthReady: false\n  },\n  getters: {\n    isLoggedIn: state => !!state.user,\n    currentUser: state => state.user,\n    authError: state => state.error,\n    isAuthReady: state => state.isAuthReady\n  },\n  mutations: {\n    SET_AUTH_READY(state, status) {\n      state.isAuthReady = status;\n    },\n    LOGIN_REQUEST(state) {\n      state.isLoggingIn = true;\n      state.error = null;\n    },\n    LOGIN_SUCCESS(state, user) {\n      state.isLoggingIn = false;\n      state.user = user;\n      state.error = null;\n      state.isAuthReady = true;\n    },\n    LOGIN_FAILURE(state, error) {\n      state.isLoggingIn = false;\n      state.user = null;\n      state.error = error;\n      state.isAuthReady = true;\n    },\n    REGISTER_REQUEST(state) {\n      state.isRegistering = true;\n      state.error = null;\n    },\n    REGISTER_SUCCESS(state, user) {\n      state.isRegistering = false;\n      state.user = user;\n      state.error = null;\n      state.isAuthReady = true;\n    },\n    REGISTER_FAILURE(state, error) {\n      state.isRegistering = false;\n      state.error = error;\n      state.isAuthReady = true;\n    },\n    LOGOUT(state) {\n      state.user = null;\n      state.error = null;\n    },\n    UPDATE_USER(state, user) {\n      state.user = user;\n    },\n    CLEAR_ERROR(state) {\n      state.error = null;\n    }\n  },\n  actions: {\n    /**\n     * Connecte un utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} credentials - Identifiants de connexion\n     * @returns {Promise} - Succès ou échec de la connexion\n     */\n    async login({\n      commit,\n      dispatch\n    }, credentials) {\n      commit('LOGIN_REQUEST');\n      try {\n        console.log('Action login: tente de connecter avec', credentials.email);\n        const response = await authService.login(credentials);\n\n        // Vérifier si la réponse contient bien un utilisateur\n        if (!response.user) {\n          throw new Error('Réponse du serveur invalide: utilisateur manquant');\n        }\n        console.log('Action login: connexion réussie, utilisateur:', response.user);\n        commit('LOGIN_SUCCESS', response.user);\n\n        // Initialiser les réservations de l'utilisateur après connexion\n        dispatch('cart/initUserBookings', null, {\n          root: true\n        });\n\n        // Ne pas gérer la redirection ici, on la laisse au composant\n\n        return response;\n      } catch (error) {\n        console.error('Action login: erreur de connexion', error);\n        const errorMessage = error.response?.data?.message || 'Erreur de connexion';\n        commit('LOGIN_FAILURE', errorMessage);\n        throw error;\n      }\n    },\n    /**\n     * Inscrit un nouvel utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} userData - Données d'inscription\n     * @returns {Promise} - Succès ou échec de l'inscription\n     */\n    async register({\n      commit,\n      dispatch\n    }, userData) {\n      commit('REGISTER_REQUEST');\n      try {\n        console.log('Action register: tente d\\'inscrire', userData.email);\n        const response = await authService.register(userData);\n\n        // Vérifier si la réponse contient bien un utilisateur\n        if (!response.user) {\n          throw new Error('Réponse du serveur invalide: utilisateur manquant');\n        }\n        console.log('Action register: inscription réussie');\n        commit('REGISTER_SUCCESS', response.user);\n\n        // Initialiser les réservations de l'utilisateur après inscription\n        dispatch('cart/initUserBookings', null, {\n          root: true\n        });\n\n        // Ne pas gérer la redirection ici, on la laisse au composant\n\n        return response;\n      } catch (error) {\n        console.error('Action register: erreur d\\'inscription', error);\n        const errorMessage = error.response?.data?.message || 'Erreur d\\'inscription';\n        commit('REGISTER_FAILURE', errorMessage);\n        throw error;\n      }\n    },\n    /**\n     * Déconnecte l'utilisateur courant\n     * @param {object} context - Contexte Vuex\n     */\n    logout({\n      commit\n    }) {\n      try {\n        console.log('Action logout: déconnexion de l\\'utilisateur');\n        authService.logout();\n        commit('LOGOUT');\n\n        // Réinitialiser les réservations à vide lors de la déconnexion\n        commit('cart/SET_BOOKINGS', [], {\n          root: true\n        });\n        router.push({\n          name: 'login'\n        });\n      } catch (error) {\n        console.error('Action logout: erreur de déconnexion', error);\n        // En cas d'erreur, on déconnecte quand même\n        commit('LOGOUT');\n        router.push({\n          name: 'login'\n        });\n      }\n    },\n    /**\n     * Vérifie si le token est toujours valide\n     * @param {object} context - Contexte Vuex\n     * @returns {Promise<boolean>} - Token valide ou non\n     */\n    async validateAuth({\n      commit,\n      state,\n      dispatch\n    }) {\n      // Si l'authentification n'est pas encore prête, on attend\n      if (!state.isAuthReady) {\n        commit('SET_AUTH_READY', true);\n      }\n\n      // Si pas d'utilisateur, pas besoin de valider\n      if (!state.user) {\n        console.log('validateAuth: pas d\\'utilisateur à valider');\n        return false;\n      }\n      try {\n        console.log('validateAuth: vérification du token');\n        const isValid = await authService.validateToken();\n\n        // Si le token n'est plus valide, déconnecter l'utilisateur\n        if (!isValid) {\n          console.log('validateAuth: token invalide, déconnexion');\n          commit('LOGOUT');\n          return false;\n        }\n        console.log('validateAuth: token valide');\n\n        // Si le token est valide, s'assurer que les réservations de l'utilisateur sont chargées\n        dispatch('cart/initUserBookings', null, {\n          root: true\n        });\n        return true;\n      } catch (error) {\n        console.error('validateAuth: erreur de validation', error);\n        commit('LOGOUT');\n        return false;\n      }\n    },\n    /**\n     * Met à jour le profil de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} userData - Nouvelles données utilisateur\n     * @returns {Promise} - Succès ou échec de la mise à jour\n     */\n    async updateProfile({\n      commit\n    }, userData) {\n      try {\n        const response = await authService.updateProfile(userData);\n        commit('UPDATE_USER', response.user);\n        return response;\n      } catch (error) {\n        console.error('updateProfile: erreur de mise à jour', error);\n        throw error;\n      }\n    },\n    /**\n     * Change le mot de passe de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} passwordData - Ancien et nouveau mot de passe\n     * @returns {Promise} - Succès ou échec du changement\n     */\n    async changePassword({\n      dispatch\n    }, passwordData) {\n      try {\n        const response = await authService.changePassword(passwordData);\n\n        // Revalider l'authentification après changement de mot de passe\n        await dispatch('validateAuth');\n        return response;\n      } catch (error) {\n        console.error('changePassword: erreur de changement', error);\n        throw error;\n      }\n    },\n    /**\n     * Initialise l'état d'authentification au démarrage de l'application\n     * @param {object} context - Contexte Vuex\n     */\n    async initAuth({\n      commit,\n      dispatch\n    }) {\n      commit('SET_AUTH_READY', false);\n      try {\n        console.log('initAuth: initialisation de l\\'authentification');\n        const user = authService.getUser();\n        const token = authService.getToken();\n        console.log('initAuth: user trouvé dans localStorage?', !!user);\n        console.log('initAuth: token trouvé dans localStorage?', !!token);\n        if (user && token) {\n          console.log('initAuth: utilisateur et token trouvés, validation...');\n          commit('LOGIN_SUCCESS', user);\n\n          // Vérifier si le token est toujours valide côté serveur\n          const isValid = await dispatch('validateAuth');\n          if (!isValid) {\n            console.log('initAuth: token invalide lors de l\\'initialisation');\n          } else {\n            console.log('initAuth: token valide, utilisateur authentifié');\n            // Charger les réservations de l'utilisateur au démarrage de l'application\n            dispatch('cart/initUserBookings', null, {\n              root: true\n            });\n          }\n        } else {\n          console.log('initAuth: pas d\\'utilisateur ou token');\n          commit('SET_AUTH_READY', true);\n        }\n      } catch (error) {\n        console.error('initAuth: erreur d\\'initialisation', error);\n        commit('SET_AUTH_READY', true);\n      }\n    },\n    /**\n     * Efface les erreurs d'authentification\n     * @param {object} context - Contexte Vuex\n     */\n    clearAuthError({\n      commit\n    }) {\n      commit('CLEAR_ERROR');\n    },\n    /**\n     * Demande de réinitialisation du mot de passe\n     * @param {object} context - Contexte Vuex\n     * @param {string} email - Email de l'utilisateur\n     * @returns {Promise} - Succès ou échec de la demande\n     */\n    async requestPasswordReset(_, email) {\n      try {\n        const response = await authService.requestPasswordReset(email);\n        return response;\n      } catch (error) {\n        console.error('requestPasswordReset: erreur', error);\n        throw error;\n      }\n    },\n    /**\n     * Réinitialise le mot de passe de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} resetData - Données de réinitialisation\n     * @returns {Promise} - Succès ou échec de la réinitialisation\n     */\n    async resetPassword(_, resetData) {\n      try {\n        const response = await authService.resetPassword(resetData);\n        return response;\n      } catch (error) {\n        console.error('resetPassword: erreur', error);\n        throw error;\n      }\n    }\n  }\n};","map":{"version":3,"names":["authService","router","namespaced","state","user","getUser","isLoggingIn","isRegistering","error","isAuthReady","getters","isLoggedIn","currentUser","authError","mutations","SET_AUTH_READY","status","LOGIN_REQUEST","LOGIN_SUCCESS","LOGIN_FAILURE","REGISTER_REQUEST","REGISTER_SUCCESS","REGISTER_FAILURE","LOGOUT","UPDATE_USER","CLEAR_ERROR","actions","login","commit","dispatch","credentials","console","log","email","response","Error","root","errorMessage","data","message","register","userData","logout","push","name","validateAuth","isValid","validateToken","updateProfile","changePassword","passwordData","initAuth","token","getToken","clearAuthError","requestPasswordReset","_","resetPassword","resetData"],"sources":["/Users/alandelaigue/Desktop/cinema-v2/src/store/modules/auth.js"],"sourcesContent":["// src/store/modules/auth.js\nimport authService from '@/services/auth.service';\nimport router from '@/router';\n\nexport default {\n  namespaced: true,\n  \n  state: {\n    user: authService.getUser(),\n    isLoggingIn: false,\n    isRegistering: false,\n    error: null,\n    isAuthReady: false\n  },\n  \n  getters: {\n    isLoggedIn: state => !!state.user,\n    currentUser: state => state.user,\n    authError: state => state.error,\n    isAuthReady: state => state.isAuthReady\n  },\n  \n  mutations: {\n    SET_AUTH_READY(state, status) {\n      state.isAuthReady = status;\n    },\n    \n    LOGIN_REQUEST(state) {\n      state.isLoggingIn = true;\n      state.error = null;\n    },\n    \n    LOGIN_SUCCESS(state, user) {\n      state.isLoggingIn = false;\n      state.user = user;\n      state.error = null;\n      state.isAuthReady = true;\n    },\n    \n    LOGIN_FAILURE(state, error) {\n      state.isLoggingIn = false;\n      state.user = null;\n      state.error = error;\n      state.isAuthReady = true;\n    },\n    \n    REGISTER_REQUEST(state) {\n      state.isRegistering = true;\n      state.error = null;\n    },\n    \n    REGISTER_SUCCESS(state, user) {\n      state.isRegistering = false;\n      state.user = user;\n      state.error = null;\n      state.isAuthReady = true;\n    },\n    \n    REGISTER_FAILURE(state, error) {\n      state.isRegistering = false;\n      state.error = error;\n      state.isAuthReady = true;\n    },\n    \n    LOGOUT(state) {\n      state.user = null;\n      state.error = null;\n    },\n    \n    UPDATE_USER(state, user) {\n      state.user = user;\n    },\n    \n    CLEAR_ERROR(state) {\n      state.error = null;\n    }\n  },\n  \n  actions: {\n    /**\n     * Connecte un utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} credentials - Identifiants de connexion\n     * @returns {Promise} - Succès ou échec de la connexion\n     */\n    async login({ commit, dispatch }, credentials) {\n      commit('LOGIN_REQUEST');\n      \n      try {\n        console.log('Action login: tente de connecter avec', credentials.email);\n        const response = await authService.login(credentials);\n        \n        // Vérifier si la réponse contient bien un utilisateur\n        if (!response.user) {\n          throw new Error('Réponse du serveur invalide: utilisateur manquant');\n        }\n        \n        console.log('Action login: connexion réussie, utilisateur:', response.user);\n        commit('LOGIN_SUCCESS', response.user);\n        \n        // Initialiser les réservations de l'utilisateur après connexion\n        dispatch('cart/initUserBookings', null, { root: true });\n        \n        // Ne pas gérer la redirection ici, on la laisse au composant\n        \n        return response;\n      } catch (error) {\n        console.error('Action login: erreur de connexion', error);\n        const errorMessage = error.response?.data?.message || 'Erreur de connexion';\n        commit('LOGIN_FAILURE', errorMessage);\n        throw error;\n      }\n    },\n    \n    /**\n     * Inscrit un nouvel utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} userData - Données d'inscription\n     * @returns {Promise} - Succès ou échec de l'inscription\n     */\n    async register({ commit, dispatch }, userData) {\n      commit('REGISTER_REQUEST');\n      \n      try {\n        console.log('Action register: tente d\\'inscrire', userData.email);\n        const response = await authService.register(userData);\n        \n        // Vérifier si la réponse contient bien un utilisateur\n        if (!response.user) {\n          throw new Error('Réponse du serveur invalide: utilisateur manquant');\n        }\n        \n        console.log('Action register: inscription réussie');\n        commit('REGISTER_SUCCESS', response.user);\n        \n        // Initialiser les réservations de l'utilisateur après inscription\n        dispatch('cart/initUserBookings', null, { root: true });\n        \n        // Ne pas gérer la redirection ici, on la laisse au composant\n        \n        return response;\n      } catch (error) {\n        console.error('Action register: erreur d\\'inscription', error);\n        const errorMessage = error.response?.data?.message || 'Erreur d\\'inscription';\n        commit('REGISTER_FAILURE', errorMessage);\n        throw error;\n      }\n    },\n    \n    /**\n     * Déconnecte l'utilisateur courant\n     * @param {object} context - Contexte Vuex\n     */\n    logout({ commit }) {\n      try {\n        console.log('Action logout: déconnexion de l\\'utilisateur');\n        authService.logout();\n        commit('LOGOUT');\n        \n        // Réinitialiser les réservations à vide lors de la déconnexion\n        commit('cart/SET_BOOKINGS', [], { root: true });\n        \n        router.push({ name: 'login' });\n      } catch (error) {\n        console.error('Action logout: erreur de déconnexion', error);\n        // En cas d'erreur, on déconnecte quand même\n        commit('LOGOUT');\n        router.push({ name: 'login' });\n      }\n    },\n    \n    /**\n     * Vérifie si le token est toujours valide\n     * @param {object} context - Contexte Vuex\n     * @returns {Promise<boolean>} - Token valide ou non\n     */\n    async validateAuth({ commit, state, dispatch }) {\n      // Si l'authentification n'est pas encore prête, on attend\n      if (!state.isAuthReady) {\n        commit('SET_AUTH_READY', true);\n      }\n      \n      // Si pas d'utilisateur, pas besoin de valider\n      if (!state.user) {\n        console.log('validateAuth: pas d\\'utilisateur à valider');\n        return false;\n      }\n      \n      try {\n        console.log('validateAuth: vérification du token');\n        const isValid = await authService.validateToken();\n        \n        // Si le token n'est plus valide, déconnecter l'utilisateur\n        if (!isValid) {\n          console.log('validateAuth: token invalide, déconnexion');\n          commit('LOGOUT');\n          return false;\n        }\n        \n        console.log('validateAuth: token valide');\n        \n        // Si le token est valide, s'assurer que les réservations de l'utilisateur sont chargées\n        dispatch('cart/initUserBookings', null, { root: true });\n        \n        return true;\n      } catch (error) {\n        console.error('validateAuth: erreur de validation', error);\n        commit('LOGOUT');\n        return false;\n      }\n    },\n    \n    /**\n     * Met à jour le profil de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} userData - Nouvelles données utilisateur\n     * @returns {Promise} - Succès ou échec de la mise à jour\n     */\n    async updateProfile({ commit }, userData) {\n      try {\n        const response = await authService.updateProfile(userData);\n        commit('UPDATE_USER', response.user);\n        return response;\n      } catch (error) {\n        console.error('updateProfile: erreur de mise à jour', error);\n        throw error;\n      }\n    },\n    \n    /**\n     * Change le mot de passe de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} passwordData - Ancien et nouveau mot de passe\n     * @returns {Promise} - Succès ou échec du changement\n     */\n    async changePassword({ dispatch }, passwordData) {\n      try {\n        const response = await authService.changePassword(passwordData);\n        \n        // Revalider l'authentification après changement de mot de passe\n        await dispatch('validateAuth');\n        \n        return response;\n      } catch (error) {\n        console.error('changePassword: erreur de changement', error);\n        throw error;\n      }\n    },\n    \n    /**\n     * Initialise l'état d'authentification au démarrage de l'application\n     * @param {object} context - Contexte Vuex\n     */\n    async initAuth({ commit, dispatch }) {\n      commit('SET_AUTH_READY', false);\n      \n      try {\n        console.log('initAuth: initialisation de l\\'authentification');\n        const user = authService.getUser();\n        const token = authService.getToken();\n        \n        console.log('initAuth: user trouvé dans localStorage?', !!user);\n        console.log('initAuth: token trouvé dans localStorage?', !!token);\n        \n        if (user && token) {\n          console.log('initAuth: utilisateur et token trouvés, validation...');\n          commit('LOGIN_SUCCESS', user);\n          \n          // Vérifier si le token est toujours valide côté serveur\n          const isValid = await dispatch('validateAuth');\n          \n          if (!isValid) {\n            console.log('initAuth: token invalide lors de l\\'initialisation');\n          } else {\n            console.log('initAuth: token valide, utilisateur authentifié');\n            // Charger les réservations de l'utilisateur au démarrage de l'application\n            dispatch('cart/initUserBookings', null, { root: true });\n          }\n        } else {\n          console.log('initAuth: pas d\\'utilisateur ou token');\n          commit('SET_AUTH_READY', true);\n        }\n      } catch (error) {\n        console.error('initAuth: erreur d\\'initialisation', error);\n        commit('SET_AUTH_READY', true);\n      }\n    },\n    \n    /**\n     * Efface les erreurs d'authentification\n     * @param {object} context - Contexte Vuex\n     */\n    clearAuthError({ commit }) {\n      commit('CLEAR_ERROR');\n    },\n    \n    /**\n     * Demande de réinitialisation du mot de passe\n     * @param {object} context - Contexte Vuex\n     * @param {string} email - Email de l'utilisateur\n     * @returns {Promise} - Succès ou échec de la demande\n     */\n    async requestPasswordReset(_, email) {\n      try {\n        const response = await authService.requestPasswordReset(email);\n        return response;\n      } catch (error) {\n        console.error('requestPasswordReset: erreur', error);\n        throw error;\n      }\n    },\n    \n    /**\n     * Réinitialise le mot de passe de l'utilisateur\n     * @param {object} context - Contexte Vuex\n     * @param {object} resetData - Données de réinitialisation\n     * @returns {Promise} - Succès ou échec de la réinitialisation\n     */\n    async resetPassword(_, resetData) {\n      try {\n        const response = await authService.resetPassword(resetData);\n        return response;\n      } catch (error) {\n        console.error('resetPassword: erreur', error);\n        throw error;\n      }\n    }\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}